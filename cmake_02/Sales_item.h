#include <string>
#include <iostream>
#include <ostream>
// 定义销售商品类
// 1. 类体可以为空，类体定义组成该类型的数据和操作
// 2. 数据称为数据成员
// 3. 类可以包含0个 到 多个private 或 public访问标号
// 4. 访问标号控制类成员在类外部是否可访问。
// 5. 使用该类的代码可能只能访问public 成员
// 6. 定义了类，也就是定义了一种新的类型
// 7. 类名就是该类型的名字
// 8. 类不是在类定义里定义数据成员时初始化数据成员
// 9. 通过称为构造函数的特殊成员函数控制初始化
// 10. 类的头文件，名字在使用前必须先声明或定义
// 11. 由多个文件组成的程序需要一种方法连接名字的使用和声明，c++通过头文件实现
// 12. 头文件一般包含类的定义，extern变量的声明和函数声明。
// 13. 使用或定义这些实体的文件要包含适当的头文件。
// 14. 设计头文件，记住定义和声明的区别很重要，定义只能出现一次，而声明可以出现多次
// 15. extern int ival = 10 ;  初始化了，所以是定义
// 16. double rate;  没有extern，所以是定义
// 17. 构造函数是特殊的成员函数，与类同名，没有返回类型，构造函数也有形参（可能为空）和函数体
// 18. 一个类可以有多个构造函数

class Sales_item
{
    // 1. 操作符重载和友元关系
    // 2. 操作符定义为非成员函数时，通常必须将他们设置为锁操作类的友元
    // 3. 在某些情况下，允许特定的非成员函数访问一个类的私有成员，同时仍然阻止一般的访问。
    // 4. 友元（friend）机制允许一个类将对齐非公有成员的访问授予指定的函数或类。
    // 5. 友元声明以关键字friend开始，只能出现在类定义的内部
    // 6. 友元声明可以出现在类中任何地方
    // 7. 通常将 友元声明成组地放在类定义的开始或者结尾
    friend std::ostream& 
        operator>>(std::istream&, Sales_item&);
    friend std::ostream& 
        operator<<(std::ostream&,const Sales_item&);
private:
    /* data */
    std::string isbn; // 图书编号
    unsigned units_sold;// 销售单位
    double revenue; //收入

public:
    // 1. 定义Sales_item的构造函数，这个函数的形参表和函数体为空
    // 2. 冒号和花括号之间的代码称为构造函数初始化列表
    // 3. 构造函数初始化列表为类的一个或多个数据成员指定初值
    // 4. 初始化列表，跟在构造函数形参表之后，以冒号开头
    // 5. 构造函数初始化是一系列成员名，每个成员后面是括在圆括号中的初始值
    // 6. 多个成员的初始化用逗号分隔
    // 7. 如果没有为一个类显试定义任何构造函数，编译器将自动为这个类生成默认构造函数
    // 8. 由编译器创建的默认构造函数通常称为合成的默认构造函数
    // 9. 有类类型的成员，则会调用该成员所属类自身的默认构造函数实现初始化
    // 10. 内置类型成员的初始值依赖于对象如何定义，如果对象在全局作用域中定义（即不在任何函数中），或定义为静态局部对象，这些成员将被初始化为0
    // 11. 如果对象在局部作用域中定义，则这些成员没有初始化 
    Sales_item(/* args */): units_sold(0),revenue(0.0){};
    ~Sales_item();
    // 1. 不将加操作符设置为友元，它可以用public 成员opertator+= 实现
    Sales_item& operator+=(const Sales_item&);
};
Sales_item::Sales_item(/* args */)
{
}

Sales_item::~Sales_item()
{
}

Sales_item operator+(const Sales_item&, const Sales_item&);
